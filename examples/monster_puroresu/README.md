# Etripator Walkthrough
## Disassembling Monster Puroresu/Monster Pro Wrestling
### Initial setup
We will start with nothing but a good old terminal, the **etripator** binary and the ROM (I don't want to know how you got it) of **Monster Puroresu**. So basically your working directory may look like this:
```
➜  ll
total 596
drwxr-xr-x 2 blockos blockos   4096 Oct 10 14:00 ./
drwxr-xr-x 7 blockos blockos   4096 Oct 10 13:59 ../
-rwxr-xr-x 1 blockos blockos  74187 Oct  6 19:33 etripator*
-rw-r--r-- 1 blockos blockos 524288 Oct 10 14:00 monster_puroresu.pce
```
### IRQ vectors extraction
As we are starting from scratch, the first thing to do is to a perform an automatic IRQ vectors extraction. This is done by calling **etripator** with **-i** (or **--irq-detect**).
```
➜ ./etripator -i monster_puroresu.pce 
irq_2 found at fff0 (1ff0)
irq_1 found at e058 (58)
irq_timer found at fff0 (1ff0)
irq_nmi found at fff0 (1ff0)
irq_reset found at e000 (0)
 
irq_2:
 
irq_1:
e05f short jump to e068 (00000068)
e065 short jump to e07d (0000007d)
 
irq_timer:
 
irq_nmi:
 
irq_reset:
e02f short jump to e029 (00000029)
e040 short jump to e033 (00000033)
e046 long jump to e138 (00000138) 
e049 long jump to e0cc (000000cc) 
e051 long jump to e4b5 (000004b5) 
e055 long jump to e055 (00000055) 
e05f short jump to e068 (00000068)
e065 short jump to e07d (0000007d)
```
**etripator** first outputs the logical and physical address of the 5 PC Engine IRQ vectors. A code section is automatically created for IRQ vector. Each section will be output in a different file. Namely:
 * irq_1.asm
 * irq_2.asm
 * irq_timer.asm
 * irq_nmi.asm
 * irq_reset.asm
 
Then comes a summary of the disassembly of each section. Each time a branch or jump instruction, the address where the jump occurs and the destination is output.

From this output we see that irq_2, irq_timer and irq_nmi all points to the same address. The last 2 elements of the jump list of irq_reset matches the ones from irq_1. This means that both interrupts overlaps. It usually happens when there is no _return_ instruction. There could be an infinite loop before irq_1 or some jumps. When automatic IRQ vectors extraction or no size is specified in the configuration file, the disassembly of a code section stops when **RTS** or **RTI** instruction is found.

A new configuration file will be created in order to overcome those issues.
```ini
[irq_reset]
filename=startup.asm
type=code
bank=0
org=e000

[irq_dummy]
filename=startup.asm
type=code
bank=0
org=fff0

[irq_vectors]
filename=startup.asm
type=inc_data
bank=0
org=fff6
size=a
```

Before running **etripator** with the new configuration, we should remove the files generated by the IRQ vectors extraction in order to keep a somehow clean workspace.
```
➜  rm *.asm
➜  ./etripator monster.cfg monster_puroresu.pce 
 
irq_reset:
e02f short jump to e029 (00000029)
e040 short jump to e033 (00000033)
e046 long jump to e138 (00000138) 
e049 long jump to e0cc (000000cc) 
e051 long jump to e4b5 (000004b5) 
e055 long jump to e055 (00000055) 
e05f short jump to e068 (00000068)
e065 short jump to e07d (0000007d)
 
irq_dummy:
```

Let's take a look at _startup.asm_.
```
	.code
	.bank 0
	.org $e000
irq_reset:
          NOP     
          SEI     
          CSH     
          CLD     
          LDA     #$ff
          TAM     #$00
          LDA     #$f8
          TAM     #$01
          LDA     #$04
          TAM     #$02
          LDA     #$05
          TAM     #$03
          LDA     #$01
          TAM     #$04
          LDA     #$02
          TAM     #$05
          LDA     #$03
          TAM     #$06
          LDA     #$00
          TAM     #$07
          LDX     #$ff
          TXS     
          CLX     
          CLA     
le029_00:
          STA     <$00, X
          STA     $2100, X
          INX     
          BNE     le029_00
          LDY     #$07
le033_00:
          DEY     
          STY     $0800
          STZ     $0804
          STZ     $0805
          STZ     $0807
          BNE     le033_00
          LDX     #$c4
          LDY     #$be
          JSR     le138_00
          JSR     le0cc_00
          LDA     #$05
          STA     $1402
          JSR     le4b5_00
          CLI     
le055_00:
          JMP     le055_00
          LDA     $0000
          STA     <$10
          AND     #$20
          BNE     le068_00
          LDA     <$10
          AND     #$04
          BNE     le07d_00
          RTI     

	.code
	.bank 0
	.org $fff0
irq_dummy:
          RTI     

	.data
	.bank 0
	.org $fff6
irq_vectors:
    .db $f0,$ff,$58,$e0,$f0,$ff,$f0,$ff
    .db $00,$e0
```

Everything seems OK. Except that irq_1 and irq_reset are fused together.

### irq_reset
irq_reset is the first piece of code executed when you power up your console.


```
          NOP     
          SEI
```
The **NOP** instruction does nothing. You can see it as a 2 cycles wait. **SEI** disables interruptions. 


```
          CSH     
          CLD     
```
The CPU is switched high speed (**CSH**) and the decimal flag is cleared (**CLD**).

```
          LDA     #$ff
          TAM     #$00
          LDA     #$f8
```
Maps the I/O page to mpr #0 and  the RAM page to mpr #1.


```
          LDA     #$04
          TAM     #$02
          LDA     #$05
          TAM     #$03
          LDA     #$01
          TAM     #$04
          LDA     #$02
          TAM     #$05
          LDA     #$03
          TAM     #$06
          LDA     #$00
          TAM     #$07
```
Maps some ROM banks to mpr #2 to #7.


```
          LDX     #$ff
          TXS     
```
Reset stack pointer. The stack index is decremented each time a byte is pushed onto the stack.

```
          CLX     
          CLA     
le029_00:
          STA     <$00, X
          STA     $2100, X
          INX     
          BNE     le029_00
```
Clears zero-page and stack memory. le029_00 can be renamed to .clear_zp_sp. This is done by creating what is called a label definition file. Here we will call it labels.cfg.
```ini                                                                                                                                                 
[.clear_zp_sp]
logical=e029
physical=000029
```

Back on irq_reset.
```
          LDY     #$07
le033_00:
          DEY     
          STY     $0800
          STZ     $0804
          STZ     $0805
          STZ     $0807
          BNE     le033_00
```
$0800 is the PSG channel select register. $0804 is the PSG channel control register, $0805 channel balance and $0807 noise control register. Basically this loops will mute every PSG channels. A new entry may be added to the label definition file. For example, le033_00 will be renamed .mute_channels.
```ini
[.mute_channels]
logical=e033
physical=000
```

We are nearly at the end of irq_reset.
```
          LDX     #$c4
          LDY     #$be
          JSR     le138_00
          JSR     le0cc_00
          LDA     #$05
          STA     $1402
          JSR     le4b5_00
          CLI     
le055_00:
          JMP     le055_00
          
          LDA     $0000
          STA     <$10
          AND     #$20
          BNE     le068_00
          LDA     <$10
          AND     #$04
          BNE     le07d_00
          RTI     
```
There is an infinite loop at le055_00. Remember that irq_1 starts at $e058 which is just after **_JMP le055_00_**.  This means that we can calculte the size of the irq_reset section, which is 88 (#$58 in hexadecimal). The section for le138_00, le0cc_00 and le4b5_00 routines can also be added.
```ini
[irq_reset]
filename=startup.asm
type=code
bank=0
org=e000
size=58

[irq_1]
filename=startup.asm
type=code
bank=0
org=e058

[unknown0]
filename=startup.asm
type=code
bank=0
org=e138

[unknown1]
filename=startup.asm
type=code
bank=0
org=e0cc

[unknown2]
filename=startup.asm
type=code
bank=0
org=e4b5

; [...] 
```
The label definition files is updated as follow.
```ini
[clear_zp_sp]
logical=e029
physical=000029

[.mute_channels]
logical=e033
physical=000033

[.loop]
logical=e055
physical=000055
```

Run **etripator** with the **-l** (or **--labels**) options.
```
➜ ./etripator -l labels.cfg monster.cfg monster_puroresu.pce 
irq_reset:
e02f short jump to e029 (00000029)
e040 short jump to e033 (00000033)
e046 long jump to e138 (00000138) 
e049 long jump to e0cc (000000cc) 
e051 long jump to e4b5 (000004b5) 
e055 long jump to e055 (00000055) 
 
irq_1:
e05f short jump to e068 (00000068)
e065 short jump to e07d (0000007d)
 
unknown0:
e142 short jump to e146 (00000146)
e159 short jump to e15d (0000015d)
 
unknown1:
 
unknown2:
 
irq_dummy:
```

Opens startup.asm. Labels in irq_reset may have been replaced by the ones defined in the label definition file.
```
	.code
	.bank 0
	.org $e000
irq_reset:
          NOP     
          SEI     
          CSH     
          CLD     
          LDA     #$ff
          TAM     #$00
          LDA     #$f8
          TAM     #$01
          LDA     #$04
          TAM     #$02
          LDA     #$05
          TAM     #$03
          LDA     #$01
          TAM     #$04
          LDA     #$02
          TAM     #$05
          LDA     #$03
          TAM     #$06
          LDA     #$00
          TAM     #$07
          LDX     #$ff
          TXS     
          CLX     
          CLA     
clear_zp_sp:
          STA     <$00, X
          STA     $2100, X
          INX     
          BNE     clear_zp_sp
          LDY     #$07
.mute_channels:
          DEY     
          STY     $0800
          STZ     $0804
          STZ     $0805
          STZ     $0807
          BNE     .mute_channels
          LDX     #$c4
          LDY     #$be
          JSR     unknown0
          JSR     unknown1
          LDA     #$05
          STA     $1402
          JSR     unknown2
          CLI     
.loop:
          JMP     .loop
```

### irq_1
The current disassembly of irq_1 is :
```
        .code
        .bank 0
        .org $e058
irq_1:
          LDA     $0000
          STA     <$10
          AND     #$20
          BNE     le068_01
          LDA     <$10
          AND     #$04
          BNE     le07d_01
          RTI 
```
The automatic disassembly stops at the RTI instruction. Nevertheless, there are 2 conditional branches.
One to $e068 and another one to $e07d.
Let's extend irq_1 section to #$30.

```ini
[irq_1]
filename=startup.asm
type=code
bank=0
org=e058
size=30
```
Unfortunately that is too low.
```
irq_1:    
          LDA     $0000
          STA     <$10
          AND     #$20
          BNE     le068_01
          LDA     <$10
          AND     #$04
          BNE     le07d_01
          RTI                                                                          
le068_01:
          JSR     unknown2
          JSR     le0ad_01
          JSR     la0b6_01
          JSR     unknown1
          JSR     le4ca_01
          JSR     lfbc2_01
          INC     <$08
          RTI                                                                          
le07d_01:
          PHA
          LDA     #$07
          STA     $0000
          LDA     #$00
          STA     $0002
```

Expand it to #$60.  We see that 

```
le07d_01:
          PHA     
          LDA     #$07
          STA     $0000
          LDA     #$00
          STA     $0002
          LDA     #$01
          STA     $0003
          LDA     #$08
          STA     $0000
          LDA     #$80
          STA     $0002
          LDA     #$01
          STA     $0003
          LDA     #$05
          STA     $0000
          LDA     #$8c
          STA     $0002
          LDA     <$41
          STA     $0003
          PLA     
          RTI     
le0ad_01:
          LDA     #$07
          STA     $0000
          LDA     <$04
          STA     $0002
          LDA     <$05
```
An RTI is caught but the size of the section is a little too big.
Hopefully, the $e0ad subroutine starts just after.
The section size is then #$e0ad-#$e058 which is equals to #$55.
```
irq_1:
          LDA     $0000
          STA     <$10
          AND     #$20
          BNE     le068_01
          LDA     <$10
          AND     #$04
          BNE     le07d_01
          RTI     
le068_01:
          JSR     unknown2
          JSR     le0ad_01
          JSR     la0b6_01
          JSR     unknown1
          JSR     le4ca_01
          JSR     lfbc2_01
          INC     <$08
          RTI     
le07d_01:
          PHA     
          LDA     #$07
          STA     $0000
          LDA     #$00
          STA     $0002
          LDA     #$01
          STA     $0003
          LDA     #$08
          STA     $0000
          LDA     #$80
          STA     $0002
          LDA     #$01
          STA     $0003
          LDA     #$05
          STA     $0000
          LDA     #$8c
          STA     $0002
          LDA     <$41
          STA     $0003
          PLA     
          RTI
```
irq_1 starts by comparing if the 6th bit of the VDC status register. This bit is set when a vertical blank interrupt occurs. le068_01 can be renamed .vblank. Next, the 3th bit is tested which is set when the raster compare (of horizontal blank) interrupt occurs. Hence le07d_01 can be renamed .hblank. 

.vblank successively jumps to 6 subroutines. 2 of them were already encountered (they are named unknown1 and unknown2 for the moment). 3 subroutines are located in the first bank (le0ad_01, le4ca_01 and lfbc2_01). In order to indentify the ROM bank where la0b6_b1 is, the value of the MPR #5 (#$a0b6 >> 13 = 5). The ROM bank #0 subroutines will be examined first in order to see if the mpr #5 is explicitely mapped. If that is not the case, the value set in the irq_reset will be used (#$02). 

We will look at those subroutines in order.

### $e4b5 (unknown2)
```
unknown2:
          LDA     #$05
          STA     $0
          LDA     <$40
          STA     $0002
          LDA     <$41
          STA     $0003
          RTS     
```
This routine simply the VDC Control register using the values stored at $2040 and $2041. It can safely be named set_vdc_ctrl.

### $e0ad
```
le0ad_01:
          LDA     #$07
          STA     $0000
          LDA     <$04
          STA     $0002
          LDA     <$05
          STA     $0003
          LDA     #$08
          STA     $0000
          LDA     <$06
          STA     $0002
          LDA     <$07
          STA     $0003
          RTS     
```
$e0ad sets VDC scroll registers using $2004, $2005 for X, and $2006, $2007 for Y.
It's safe to name it update_scroll.

### $a0b6
In order to find where this routine, we must find the value of the mpr #5. From the irq_reset code, we have:
```
          LDA     #$02
          TAM     #$05
```
In order not to bloat startup.asm, the routine from bank #2 will be disassembled in a separate file (bank2.asm).
```ini
[unknown8]
filename=bank2.asm
type=code
bank=2
org=a0b6
 ```
Automatic extraction does not work very well here as the routine jumps to a location stored in a table. In fact there are 2 tables. One starting at $a0dd and the other at $a1dd. 

```
	.code
	.bank 2
	.org $a0b6
unknown8:
          LDA     <$09
          CMP     #$80
          BCS     la0cb_10
          ASL     A
          TAX     
          LDA     $a0dd, X
          STA     <$28
          LDA     $a0de, X
          STA     <$29
          JMP     [$2028]
la0cb_10:
          SEC     
          SBC     #$80
          ASL     A
          TAX     
          LDA     $a1dd, X
          STA     <$28
          LDA     $a1de, X
          STA     <$29
          JMP     [$2028]
```
We will keep it as is for the moment.

### $e0cc (unknown1)
```
	.code
	.bank 0
	.org $e0cc
unknown1:
          LDA     #$00
          STA     $0000
          LDA     #$00
          STA     $0002
          LDA     #$7f
          STA     $0003
          LDA     #$02
          STA     $0000
          TIA     $2200, $0002, $0200
          LDA     #$13
          STA     $10
          LDA     #$00
          STA     $0002
          LDA     #$7f
          STA     $0003
          RTS     
```
512 bytes from RAM at $2200 are copied to the VDC RAM at $7f00. Then the VRAM-SATB DMA is started. It's safe to rename unknown1 update_satb.

### $e4ca
The almighty joypad read routine, with multi-tap support and the run+select reboot combo.
```
	.code
	.bank 0
	.org $e4ca
read_joy:
          CLY     
          LDA     #$01
          STA     $1000
          LDA     #$03
          STA     $1000
.next_joypad:
          LDA     #$01
          STA     $1000
          PHA     
          PLA     
          NOP     
          LDA     $2030, Y
          STA     $2035, Y
          LDA     $1000
          ASL     A
          ASL     A
          ASL     A
          ASL     A
          STA     $2030, Y
          STZ     $1000
          PHA     
          PLA     
          NOP     
          LDA     $1000
          AND     #$0f
          ORA     $2030, Y
          EOR     #$ff
          STA     $2030, Y
          EOR     $2035, Y
          AND     $2030, Y
          STA     $203a, Y
          INY     
          CPY     #$05
          BCC     .next_joypad
          LDA     <$3a
          CMP     #$04
          BNE     .read_joy_end
          LDA     <$30
          CMP     #$0c
          BNE     .read_joy_end
          JMP     soft_reset
.read_joy_end:
          RTS 
```

### $fbc2
This routine can be split in 4 parts. First, mpr 2, 3 and 4 are mapped to hucard pages $07, $08 and $09. Then the same routine $fcac is called repeatedly with different values of X ($00, $02, $04, $06, $08, $0a). The same is done with $fd36 ($00, $10). Finally, the mpr 4 is set to hucard page 01.
```
	.code
	.bank 0
	.org $fbc2
unknown5:
          LDA     #$07
          TAM     #$02
          LDA     #$08
          TAM     #$03
          LDA     #$09
          TAM     #$04
          LDX     #$00
          JSR     $fcac
          LDX     #$02
          JSR     $fcac
          LDX     #$04
          JSR     $fcac
          LDX     #$06
          JSR     $fcac
          LDX     #$08
          JSR     $fcac
          LDX     #$0a
          JSR     $fcac
          LDX     #$00
          JSR     $fd36
          LDX     #$10
          JSR     $fd36
          LDA     #$01
          TAM     #$04
          RTS     
```
A quick look at $fcac shows that $fbc2 is in fact the sound fx/music routine and $fcac the PSG channel update.
Let's switch back to irq_reset. We will get back to it afterwards. The only remaining unknown routine there is $e138.

## $e138 (unknown0)
```
	.code
	.bank 0
	.org $e138
unknown0:
          STX     <$20
          STY     <$21
          LDY     #$00
          LDA     [$20], Y
          INC     <$20
          BNE     le146_02
          INC     <$21
le146_02:
          ASL     A
          TAX     
          LDA     $e170, X
          STA     <$22
          LDA     $e171, X
          STA     <$23
          JMP     [$2022]
          LDA     [$20], Y
          INC     <$20
          BNE     le15d_02
          INC     <$21
le15d_02:
          RTS  
```
Once again the automatic routine extraction went too far. The code right after JMP [$2022] is never reached.
